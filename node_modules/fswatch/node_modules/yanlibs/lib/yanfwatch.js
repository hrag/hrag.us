var fs = require('fs'),
    readupFileSync = require('yanlibs/lib/yanfs').readupFileSync,
    watchFile = fs.watchFile,
    unwatchFile = fs.unwatchFile,
    print = require('sys').print;

// log

var log = null;

exports.setLog = function(logf) {
    log = logf;
};

// parsers

var parsers = {};

exports.registerParser = function(parserid, module) {
    parsers[parserid] = module;
};

// subscribe / unsubscribe

var subscribers = {},
    sequence = 0;

exports.subscribe = function(fname, evmatcher, evpreprocessor, callbacks) {
    var suid = 'yanfswatchsuid' + sequence++,
        s = subscribers[fname];

    if (typeof callbacks === 'function') callbacks = [callbacks];

    if (s) {
        s.suids.push(suid); // store the order of subscribers
        s.entries[suid] = { evm: evmatcher, pre: evpreprocessor, c: callbacks };
    } else {
        subscribers[fname] = s = { suids: [suid], entries: {} };
        s.entries[suid] = { evm: evmatcher, pre: evpreprocessor, c: callbacks };
        watch(fname);
    }

    return suid;
};

exports.unsubscribe = function(suid) {
    var s, k, i;

    for (k in subscribers) {
        s = subscribers[k];
        i = s.suids.indexOf(suid);
        if (i > -1) {
            s.suids.splice(i, 1);
            delete s.entries[suid];
            if (s.suids.length == 0) exports.unsubscribeAll(k);
            return;
        }
    }
};

exports.unsubscribeAll = function(fname) {
    unwatchFile(fname);
    delete subscribers[fname];
    delete evfiles[fname];
};

// exec

var execQueue = [],
    chExec = require('child_process').exec,
    canExec = true;

function _exec(path, skipEvents) {
    canExec = false;
    retrieveEvents = !skipEvents;
    chExec(path, function(error, stdout, stderr) {
        print(stdout + stderr);
        error !== null && print('error: ' + error);
        canExec  = true;
        retrieveEvents = true;
    });
};

exports.exec = function(path, skipEvents) {
    if (typeof path === 'string' && path.trim().length) {
        execQueue.push({ path: path, skipEvents: skipEvents });
    }
};

// jobs

function startJobsInterval(interval) {
    var t;

    setInterval(function() {
        if (canExec) {
            if (execQueue.length) {
                t = execQueue.shift();
                _exec(t.path, t.skipEvents);
            } else if (callbackQueue.length) {
                t = callbackQueue.shift();
                t.c(t.pevent);
            }
        }
    }, interval);
}

// events

var queue = { order: [], events: {} },
    retrieveEvents = true;

function pushEvent(fname, event) {
    if (retrieveEvents) {
        var eventf = event.substring(event.indexOf('/')),
            key = fname + ' ' + eventf,
            oi,
            t;

        if (!log || !log.logpath || log.logpath !== eventf) {
            log && log('event.got (' + event + ')');

            queue.events[key] = { fname: fname, event: event };
            if ((oi = queue.order.indexOf(key)) !== -1) {
                t = queue.order.splice(oi, 1)[0];
                log && log('queue.order.delete (' + t + ')');
            }

            log && log('queue.order.push (' + key + ')');
            queue.order.push(key);
        }
    }
}

function copyEvent(event) {
    var result = {};

    for (var k in event) result[k] = event[k];

    return result;
}

// listener

var dinterval = 1000,
    callbackQueue = [];

exports.start = function(interval) {
    interval = interval === undefined || interval < 0 ? dinterval : interval;

    startJobsInterval(500);
    setInterval(function() {
        var ekey, s, e, pevent, entry, path;
        if (canExec && queue.order.length) {
            ekey = queue.order.shift();
            log && log('queue.order.shift (' + ekey + ')');
            e = queue.events[ekey];
            s = subscribers[e.fname];
            if (s) {
                s.suids.forEach(function(suid) {
                    entry = s.entries[suid];
                    pevent = parse(e.event);
                    if (pevent) {
                        path = pevent.path;
                        entry.pre && (pevent = entry.pre(pevent));
                        if ((entry.evm instanceof RegExp && entry.evm.test(path)) || entry.evm(e.event, pevent)) {
                            entry.c.forEach(function(c) { callbackQueue.push({ c: c, pevent: copyEvent(pevent) }) });
                        }
                    }
                });
            }
        }
    }, interval);
};

// watcher

var evfiles = {};

function watch(fname) {
    var s, tail, events;
    evfiles[fname] = { nread: 0 };

    watchFile(fname, function(curr, prev) {
        if (curr.mtime != prev.mtime) {
            s = subscribers[fname];
            if (s) {
                tail = readupFileSync(fname, evfiles[fname].nread, 'utf8');
                events = tail.data.split('\n');
                if (events.length > 0) {
                    evfiles[fname].nread += (tail.nread - events[events.length - 1].length);
                    events.forEach(function(event) {
                        if (event.trim().length > 0) {
                            pushEvent(fname, event);
                        }
                    });
                }
            }
        }
    });
}

function parse(event) {
    if (event && (event = event.trim())) {
        var i = event.indexOf(' '),
            parser = parsers[i !== -1 ? event.substring(0, i) : event];

        if (parser && parser.parse) return parser.parse(event);
    }
}
